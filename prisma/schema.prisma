// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Used for authentication
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  accounts      Account[]
  sessions      Session[]

  @@map("auth_users")
}

// Used for authentication
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("auth_accounts")
}

// Used for authentication
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("auth_sessions")
}

// Used for authentication
model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("auth_verification_tokens")
}

// Used for app
model AppUser {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  name         String
  passwordHash String?  @map("password_hash")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  authUserId String? @unique @map("auth_user_id")

  workouts         WorkoutLog[]
  personalRecords  PersonalRecord[]
  challengeResults ChallengeResult[]
  profile          Profile?
  createdTemplates WorkoutTemplate[] @relation("CreatedTemplates") // Templates I made and shared
  sharedTemplates  TemplateShare[] // Templates shared with me

  @@map("users")
}

model Profile {
  id        Int      @id @default(autoincrement())
  userId    Int      @unique @map("user_id")
  bio       String?
  avatarUrl String?  @map("avatar_url")
  height    Int?
  weight    Decimal? @db.Decimal(4, 1)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

// Used for templates for workouts to log exercise
model WorkoutTemplate {
  id          Int     @id @default(autoincrement())
  name        String
  description String?
  createdBy   Int     @map("created_by")
  isPublic    Boolean @default(false) @map("is_public")

  format       String // "AMRAP", "FOR_TIME", "EMOM"
  duration     Int? // Total minutes allowed
  targetRounds Int?   @map("target_rounds")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  exercises  TemplateExercise[]
  logs       WorkoutLog[]
  creator    AppUser            @relation("CreatedTemplates", fields: [createdBy], references: [id])
  sharedWith TemplateShare[] //Many-to-many through join table

  @@map("workout_templates")
}

model TemplateExercise {
  id          Int     @id @default(autoincrement())
  templateId  Int     @map("template_id")
  exerciseId  Int     @map("exercise_id")
  targetValue Float   @map("target_value")
  targetUnit  String  @map("target_unit")
  orderIndex  Int     @map("order_index")
  notes       String?

  template WorkoutTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  exercise Exercise        @relation(fields: [exerciseId], references: [id])

  @@map("template_exercises")
}

// Templates can have multiple users / users can have multiple templates
model TemplateShare {
  id         Int      @id @default(autoincrement())
  templateId Int      @map("template_id")
  userId     Int      @map("user_id")
  sharedAt   DateTime @default(now()) @map("shared_at")

  template WorkoutTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  user     AppUser         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([templateId, userId])
  @@index([userId])
  @@index([templateId])
  @@map("template_shares")
}

model WorkoutLog {
  id          Int      @id @default(autoincrement())
  userId      Int      @map("user_id")
  templateId  Int?     @map("template_id")
  completedAt DateTime @map("completed_at")

  // Summary metrics:
  roundsCompleted Float @map("rounds_completed")
  totalDuration   Int   @map("total_duration") // includes rest
  totalWorkTime   Int   @map("total_work_time") // excludes rest
  totalRestTime   Int   @map("total_rest_time")

  status String  @default("COMPLETED") // "COMPLETED", "ABANDONED"
  notes  String?

  template       WorkoutTemplate? @relation(fields: [templateId], references: [id])
  user           AppUser          @relation(fields: [userId], references: [id])
  rounds         WorkoutRound[]
  PersonalRecord PersonalRecord[]

  @@map("workout_logs")
}

// This is the key table for tracking performance over time:
model WorkoutRound {
  id          Int @id @default(autoincrement())
  logId       Int @map("log_id")
  roundNumber Int @map("round_number")

  startedAt   DateTime @map("started_at")
  completedAt DateTime @map("completed_at")

  duration  Int // seconds for this round (work time only)
  restAfter Int? @map("rest_after") // seconds of rest after this round

  log       WorkoutLog      @relation(fields: [logId], references: [id], onDelete: Cascade)
  exercises RoundExercise[] // Individual exercise times within the round

  @@unique([logId, roundNumber])
  @@index([logId])
  @@map("workout_rounds")
}

// Granular tracking per exercise per round:
model RoundExercise {
  id         Int @id @default(autoincrement())
  roundId    Int @map("round_id")
  exerciseId Int @map("exercise_id")

  startedAt   DateTime @map("started_at")
  completedAt DateTime @map("completed_at")
  duration    Int // seconds on this specific exercise
  restAfter   Int? @map("rest_after") // seconds of rest after this exercise

  // What they actually did (vs template target):
  actualValue Float   @map("actual_value")
  actualUnit  String  @map("actual_unit")
  scaled      Boolean @default(false) // Did they modify from template?

  round    WorkoutRound @relation(fields: [roundId], references: [id], onDelete: Cascade)
  exercise Exercise     @relation(fields: [exerciseId], references: [id])

  @@index([roundId])
  @@map("round_exercises")
}

model Exercise {
  id       Int    @id @default(autoincrement())
  name     String @unique
  category String

  templateExercises TemplateExercise[]
  roundExercises    RoundExercise[]
  personalRecords   PersonalRecord[]
  Challenge         Challenge[]

  @@map("exercises")
}

model PersonalRecord {
  id           Int      @id @default(autoincrement())
  userId       Int      @map("user_id")
  exerciseId   Int      @map("exercise_id")
  value        Float
  timeTaken    Int?     @map("time_taken")
  achievedDate DateTime @map("achieved_date")
  workoutId    Int?     @map("workout_id")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user     AppUser     @relation(fields: [userId], references: [id], onDelete: Cascade)
  exercise Exercise    @relation(fields: [exerciseId], references: [id])
  workout  WorkoutLog? @relation(fields: [workoutId], references: [id])

  @@unique([userId, exerciseId, value])
  @@map("personal_records")
}

model Challenge {
  id               Int      @id @default(autoincrement())
  name             String
  description      String?
  startDate        DateTime @map("start_date")
  endDate          DateTime @map("end_date")
  challengeType    String   @map("challenge_type")
  targetExerciseId Int?     @map("target_exercise_id")
  targetValue      Float?   @map("target_value")
  createdAt        DateTime @default(now()) @map("created_at")

  targetExercise Exercise?         @relation(fields: [targetExerciseId], references: [id])
  results        ChallengeResult[]

  @@map("challenges")
}

model ChallengeResult {
  id          Int      @id @default(autoincrement())
  challengeId Int      @map("challenge_id")
  userId      Int      @map("user_id")
  resultValue Float    @map("result_value")
  rank        Int?
  updatedAt   DateTime @updatedAt @map("updated_at")

  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user      AppUser   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([challengeId, userId])
  @@index([challengeId, rank])
  @@map("challenge_results")
}
